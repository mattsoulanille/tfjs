import * as brotli from 'brotli';
import {promisify} from 'util';
import {ArgumentParser} from 'argparse';
import * as fs from 'fs';

const readFilePromise = promisify(fs.readFile);
const writeFilePromise = promisify(fs.writeFile);

const parser = new ArgumentParser({
  description: "Bundle files as base64 into a single TypeScript file.",
});

parser.addArgument(['-o', '--output'], {
  action: 'store',
  required: true,
  help: 'The output path for the typescript bundle',
});

parser.addArgument('file', {
  nargs: '+',
  help: 'A file to include in the bundle',
});

async function main() {
  const args = parser.parseArgs();
  const paths = args.file as string[];
  const buffers = await Promise.all(paths.map((f) => readFilePromise(f)));
  const compressed = buffers.map(buffer => Buffer.from(brotli.compress(buffer)));
  const base64 = compressed.map(buffer => buffer.toString('base64'));

  const zipped: Array<[string, string]> = [];
  for (let i = 0; i < paths.length; i++) {
    zipped[i] = [paths[i], base64[i]];
  }

  // Code generation
  const sourcecode = `// This file is generated by tfjs/tools/base64_bundle.ts
// (likely by //tools:base64_bundle.bzl).
import {decompress} from 'brotli';

const zipped = ${JSON.stringify(zipped)};

export const files = new Map<string, Uint8Array>();
for (const [key, compressedStr] of zipped) {
  const data = atob(compressedStr);
  const compressed = Uint8Array.from(data, c => c.charCodeAt(0));
  const decompressed = decompress(compressed as Buffer);
  files.set(key, decompressed);
}
`;
 
  writeFilePromise(args.output, sourcecode);
}

main();
